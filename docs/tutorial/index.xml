<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tutorials on Flutter Data</title>
    <link>/tutorial/</link>
    <description>Recent content in Tutorials on Flutter Data</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="/tutorial/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fetching tasks</title>
      <link>/tutorial/fetching/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/fetching/</guid>
      <description>Before you continue:
Make sure you went through the Quickstart and got Flutter Data up and running!
Also, you can check out the full source code for this tutorial at https://github.com/flutterdata/tutorial
 We now have access to our Repository&amp;lt;Task&amp;gt; through ref.tasks, with an API base URL set to https://my-json-server.typicode.com/flutterdata/demo/.
Inspecting the /tasks endpoint we see:
[ { &amp;#34;id&amp;#34;: 1, &amp;#34;title&amp;#34;: &amp;#34;Laundry ðŸ§º&amp;#34;, &amp;#34;completed&amp;#34;: false, &amp;#34;userId&amp;#34;: 1 }, { &amp;#34;id&amp;#34;: 2, &amp;#34;title&amp;#34;: &amp;#34;Groceries ðŸ›’&amp;#34;, &amp;#34;completed&amp;#34;: true, &amp;#34;userId&amp;#34;: 1 }, { &amp;#34;id&amp;#34;: 3, &amp;#34;title&amp;#34;: &amp;#34;Reservation at Malloys&amp;#34;, &amp;#34;completed&amp;#34;: true, &amp;#34;userId&amp;#34;: 1 }, // .</description>
    </item>
    
    <item>
      <title>Marking tasks as done</title>
      <link>/tutorial/updating/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/updating/</guid>
      <description>A read-only tasks app is not very practical! Let&amp;rsquo;s add the ability to update the completed state and mark/unmark our tasks as done.
First, though, we&amp;rsquo;ll extract the tasks-specific code to a separate screen named TasksScreen:
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final state = ref.tasks.watchAll(); if (state.isLoading) { return CircularProgressIndicator(); } return ListView( children: [ for (final task in state.model) Text(task.title), ], ); } } Remember to return this new widget from TasksApp:</description>
    </item>
    
    <item>
      <title>Creating a new task</title>
      <link>/tutorial/creating/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/creating/</guid>
      <description>Let&amp;rsquo;s add a TextField, turn the input into a new Task and immediately save it.
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final state = ref.tasks.watchAll(); final _newTaskController = useTextEditingController();  if (state.isLoading) { return CircularProgressIndicator(); } return ListView( children: [ TextField( controller: _newTaskController, onSubmitted: (value) async { Task(title: value).save(); _newTaskController.clear(); }, ),  for (final task in state.model) ListTile( leading: Checkbox( value: task.completed, onChanged: (value) =&amp;gt; task.</description>
    </item>
    
    <item>
      <title>Reloading the list</title>
      <link>/tutorial/reloading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/reloading/</guid>
      <description>Let&amp;rsquo;s make the number of tasks more manageable via the _limit server query param, which in this case will return a maximum of 5 resources.
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final state = ref.tasks.watchAll(params: {&amp;#39;_limit&amp;#39;: 5});  // ... } Hot restarting the app we should only see five tasks, but&amp;hellip;
       It&amp;rsquo;s exactly the same as before.</description>
    </item>
    
    <item>
      <title>Deleting tasks</title>
      <link>/tutorial/deleting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/tutorial/deleting/</guid>
      <description>There&amp;rsquo;s stuff we just don&amp;rsquo;t want to do!
We can delete a Task on dismiss by wrapping the tile with a Dismissible and calling its delete method:
class TasksScreen extends HookConsumerWidget { @override Widget build(BuildContext context, WidgetRef ref) { final state = ref.tasks.watchAll(params: {&amp;#39;_limit&amp;#39;: 5}, syncLocal: true); final _newTaskController = useTextEditingController(); if (state.isLoading) { return CircularProgressIndicator(); } return RefreshIndicator( onRefresh: () =&amp;gt; ref.tasks.findAll(params: {&amp;#39;_limit&amp;#39;: 5}, syncLocal: true), child: ListView( children: [ TextField( controller: _newTaskController, onSubmitted: (value) async { Task(title: value).</description>
    </item>
    
  </channel>
</rss>
